/*
 * v_math.h
 *
 *  Created on: 4 זמגע. 2017
 *      Author: Voodoo
 */
//==============================================================================
#include "driver\v_math.h"
//==============================================================================
long toFixed(long a)
{
  long long tmp = (long long)a << 16;
  return  (long)(tmp / 1000);
}
//==============================================================================
long toFloatX10000(long a)
{
  long long tmp = (long long)a * 10000;
  return  (long)(tmp >> 16);
}
//==============================================================================
long  q_add(long  a, long  b)
{
    return a + b;
}
//==============================================================================
//Subtraction[edit]
long  q_sub(long  a, long  b)
{
    return a - b;
}
//==============================================================================
//Multiplication[edit]
// precomputed value:

#define Q       (16) //Q refers to the fractional part's number of bits
#define K   (1 << (Q - 1))
//==============================================================================
// saturate to range of int
long long  sat16(long long  x)
{
//	if (x > 0x7FFF) return 0x7FFF;
//	else if (x < -0x8000) return -0x8000;
//	else
          return (long long)x;
}
//==============================================================================
long q_mul(long a, long  b)
{
    long result;
    long long temp;

    long long a1 = (long long )a & 0xffffffff;
    if(a & 0x80000000) a1 |= 0xffffffff00000000;
    long long b1 = (long long )b & 0xffffffff;
    if(b & 0x80000000) b1 |= 0xffffffff00000000;

    temp = (a1) * (b1); // result type is operand's type
    // Rounding; mid values are rounded up
    temp += K;
    // Correct by dividing by base and saturate result
    result = temp >> Q;//sat16(temp >> Q);
    return result;
}
//==============================================================================
//Division[edit]
long q_div(long a, long b)
{
    long result;
    long long temp;

    // pre-multiply by the base (Upscale to Q16 so that the result will be in Q8 format)
    temp = (long long)a << Q;
    // Rounding: mid values are rounded up (down for negative values).
    if((temp >= 0 && b >= 0) || (temp < 0 && b < 0)) //{  OR compare most significant bits ie. if((temp >> 31) & 1 == (temp >> 15) & 1) {
        temp += b / 2;    // OR shift 1 bit ie. temp += (b >> 1);
    else
        temp -= b / 2;    // OR shift 1 bit ie. temp -= (b >> 1);
    result = (long)(temp / b);

    return result;
}
//==============================================================================
long absol (long x)
{
  if(x & 0x80000000)
    x = q_mul(x ,toFixed(-1000));
  return x;
}
//============================
float af, bf, cf, df, xf, x1f;
//============================
#define DIF_FX (0x000001)
long sqrt_fx(long num)
{
  int i;
  long x, x1;

  if (num <= 0) return 0;
  else
  {
    i = 0;
    x1 = num;
    x = q_div(num ,toFixed(2000));
    while(i < 25)
    {
      x1 = q_sub(x, q_div(q_sub(q_mul(x,x), num), q_mul(toFixed(2000), x)));
      if(absol(q_sub(x, x1)) < DIF_FX) break;
      else
      {
        i++;
        x = x1;
      }
    }
  }
  return x1;
}
//==============================================================================
const long SIN_TABLE[] = {
0x0000, 0x0141, 0x0288, 0x03D0, 0x0518, 0x065F, 0x07A7, 0x08EF, 0x0A36, 0x0B7E, 0x0CC6, 0x0E0D, 0x0F55, 0x109D, 0x11E4,
0x132C, 0x1474, 0x15B5, 0x16FD, 0x1844, 0x198C, 0x1AD4, 0x1C15, 0x1D5C, 0x1EA4, 0x1FE5, 0x212D, 0x226E, 0x23B6, 0x24F7,
0x263F, 0x2780, 0x28C7, 0x2A09, 0x2B4A, 0x2C91, 0x2DD2, 0x2F14, 0x3055, 0x3196, 0x32D7, 0x3418, 0x3559, 0x369A, 0x37DB,
0x391D, 0x3A57, 0x3B98, 0x3CD9, 0x3E14, 0x3F55, 0x4090, 0x41CA, 0x430B, 0x4446, 0x4581, 0x46BB, 0x47F6, 0x4930, 0x4A6B,
0x4BA5, 0x4CD9, 0x4E14, 0x4F4F, 0x5083, 0x51BD, 0x52F1, 0x5425, 0x5559, 0x568D, 0x57C1, 0x58F5, 0x5A29, 0x5B5D, 0x5C91,
0x5DBF, 0x5EF3, 0x6020, 0x614E, 0x6282, 0x63AF, 0x64DD, 0x660A, 0x6731, 0x685F, 0x698C, 0x6AB3, 0x6BE0, 0x6D07, 0x6E2E,
0x6F55, 0x707C, 0x71A3, 0x72CA, 0x73EA, 0x7511, 0x7631, 0x7758, 0x7879, 0x7999, 0x7AB9, 0x7BDA, 0x7CF4, 0x7E14, 0x7F2E,
0x804E, 0x8168, 0x8282, 0x839C, 0x84B5, 0x85C9, 0x86E2, 0x87F6, 0x890F, 0x8A23, 0x8B36, 0x8C49, 0x8D56, 0x8E69, 0x8F7C,
0x9089, 0x9196, 0x92A3, 0x93AF, 0x94BC, 0x95C2, 0x96CF, 0x97D5, 0x98DB, 0x99E1, 0x9AE7, 0x9BED, 0x9CF4, 0x9DF3, 0x9EF3,
0x9FF2, 0xA0F2, 0xA1F2, 0xA2F1, 0xA3EA, 0xA4EA, 0xA5E3, 0xA6DC, 0xA7D5, 0xA8C7, 0xA9C0, 0xAAB3, 0xABA5, 0xAC98, 0xAD8A,
0xAE7D, 0xAF69, 0xB05B, 0xB147, 0xB233, 0xB31F, 0xB404, 0xB4F0, 0xB5D6, 0xB6BB, 0xB7A0, 0xB886, 0xB965, 0xBA4A, 0xBB29,
0xBC08, 0xBCE7, 0xBDBF, 0xBE9E, 0xBF76, 0xC04E, 0xC126, 0xC1FF, 0xC2D0, 0xC3A9, 0xC47A, 0xC54C, 0xC61E, 0xC6E9, 0xC7BB,
0xC886, 0xC951, 0xCA1C, 0xCAE1, 0xCBAC, 0xCC71, 0xCD35, 0xCDF3, 0xCEB8, 0xCF76, 0xD03A, 0xD0F9, 0xD1B0, 0xD26E, 0xD326,
0xD3E4, 0xD495, 0xD54C, 0xD604, 0xD6B5, 0xD765, 0xD816, 0xD8C7, 0xD972, 0xDA23, 0xDACD, 0xDB71, 0xDC1B, 0xDCC6, 0xDD6A,
0xDE0D, 0xDEB1, 0xDF4F, 0xDFEC, 0xE090, 0xE126, 0xE1C4, 0xE261, 0xE2F8, 0xE38E, 0xE425, 0xE4B5, 0xE546, 0xE5DC, 0xE66C,
0xE6F6, 0xE786, 0xE810, 0xE89A, 0xE923, 0xE9A6, 0xEA29, 0xEAB3, 0xEB2F, 0xEBB2, 0xEC2F, 0xECB2, 0xED28, 0xEDA5, 0xEE21,
0xEE97, 0xEF0D, 0xEF83, 0xEFF2, 0xF062, 0xF0D8, 0xF141, 0xF1B0, 0xF219, 0xF282, 0xF2EB, 0xF353, 0xF3B6, 0xF41F, 0xF481,
0xF4DD, 0xF53F, 0xF59B, 0xF5F6, 0xF652, 0xF6A7, 0xF6FD, 0xF752, 0xF7A7, 0xF7FC, 0xF84B, 0xF89A, 0xF8E8, 0xF930, 0xF97F,
0xF9C7, 0xFA0F, 0xFA51, 0xFA92, 0xFADA, 0xFB15, 0xFB57, 0xFB92, 0xFBD3, 0xFC08, 0xFC43, 0xFC77, 0xFCB2, 0xFCE0, 0xFD14,
0xFD42, 0xFD77, 0xFD9E, 0xFDCC, 0xFDF3, 0xFE21, 0xFE48, 0xFE69, 0xFE90, 0xFEB1, 0xFED2, 0xFEEC, 0xFF0D, 0xFF27, 0xFF41,
0xFF55, 0xFF6F, 0xFF83, 0xFF97, 0xFFAA, 0xFFB7, 0xFFC5, 0xFFD2, 0xFFDF, 0xFFE5, 0xFFEC, 0xFFF2, 0xFFF9, 0xFFF9, };
//==============================================================================
long asin_fx(long aVal)
{
  unsigned int sign = 0, i;  // 1 = negative
  if(aVal < 0)
  {
    aVal = q_mul(aVal, toFixed(-1000));
    sign = 1;
  }

   for(i = 0; i < (sizeof(SIN_TABLE) / 4); i++)
   {
     if(aVal <= SIN_TABLE[i])
     {
       long     res = q_mul(toFixed(i), toFixed( 5000));
       if(sign) res = q_mul(res,        toFixed(-1000));
       return res;
     }
   }
  return 1000;
}
//==============================================================================
long TAN_TABLE[] = {
0x0, 0x147, 0x28F, 0x3D7, 0x51E, 0x666, 0x7AE, 0x8F5, 0xA3D, 0xB85, 0xCCC, 0xE14, 0xF5C, 0x10A3, 0x11F2,
0x1339, 0x1481, 0x15CF, 0x1717, 0x185F, 0x19AD, 0x1AF4, 0x1C43, 0x1D91, 0x1ED9, 0x2027, 0x2175, 0x22C3, 0x2412, 0x2560,
0x26AE, 0x27FC, 0x294A, 0x2A9F, 0x2BED, 0x2D42, 0x2E90, 0x2FE5, 0x313A, 0x328F, 0x33E4, 0x3538, 0x368D, 0x37E2, 0x393D,
0x3A92, 0x3BED, 0x3D49, 0x3EA4, 0x4000, 0x415B, 0x42B6, 0x4418, 0x4573, 0x46D5, 0x4837, 0x4999, 0x4AFB, 0x4C63, 0x4DC5,
0x4F2E, 0x5096, 0x51FF, 0x5367, 0x54D0, 0x563F, 0x57AE, 0x591D, 0x5A8C, 0x5BFB, 0x5D70, 0x5EE6, 0x605B, 0x61D1, 0x6346,
0x64C2, 0x663F, 0x67BB, 0x6937, 0x6AB9, 0x6C36, 0x6DB8, 0x6F41, 0x70C4, 0x724D, 0x73D7, 0x7566, 0x76F0, 0x787F, 0x7A16,
0x7BA5, 0x7D3C, 0x7ED2, 0x8068, 0x8205, 0x83A2, 0x8546, 0x86E2, 0x8886, 0x8A30, 0x8BDA, 0x8D84, 0x8F2E, 0x90DE, 0x928F,
0x9446, 0x95FD, 0x97B4, 0x9972, 0x9B2F, 0x9CF4, 0x9EB8, 0xA07C, 0xA247, 0xA412, 0xA5E3, 0xA7B4, 0xA98C, 0xAB64, 0xAD42,
0xAF21, 0xB106, 0xB2EB, 0xB4D0, 0xB6C2, 0xB8AD, 0xBAA6, 0xBC9E, 0xBE97, 0xC096, 0xC29C, 0xC4A2, 0xC6AE, 0xC8BA, 0xCACD,
0xCCE7, 0xCF00, 0xD120, 0xD346, 0xD56D, 0xD79A, 0xD9CE, 0xDC08, 0xDE42, 0xE083, 0xE2CA, 0xE518, 0xE765, 0xE9BA, 0xEC1B,
0xEE76, 0xF0DE, 0xF34D, 0xF5C2, 0xF837, 0xFAB9, 0xFD3C, 0xFFCB, 0x1025A, 0x104F0, 0x10793, 0x10A36, 0x10CE7, 0x10F9D, 0x1125A,
0x1151E, 0x117E9, 0x11AB9, 0x11D97, 0x1207C, 0x12367, 0x12659, 0x12958, 0x12C5D, 0x12F6F, 0x13288, 0x135A8, 0x138D4, 0x13C08, 0x13F48,
0x14295, 0x145E9, 0x1494A, 0x14CB9, 0x1502D, 0x153AF, 0x1573E, 0x15ADA, 0x15E83, 0x1623A, 0x165F6, 0x169C7, 0x16DA5, 0x1718F, 0x1758E,
0x17993, 0x17DAB, 0x181D1, 0x1860A, 0x18A57, 0x18EB1, 0x19318, 0x1979A, 0x19C28, 0x1A0CB, 0x1A581, 0x1AA4A, 0x1AF27, 0x1B41F, 0x1B923,
0x1BE48, 0x1C37B, 0x1C8CE, 0x1CE35, 0x1D3B6, 0x1D951, 0x1DF06, 0x1E4D6, 0x1EAC0, 0x1F0CB, 0x1F6F6, 0x1FD42, 0x203A9, 0x20A30, 0x210DE,
0x217AE, 0x21EA4, 0x225C2, 0x22D01, 0x2346D, 0x23C01, 0x243C9, 0x24BB2, 0x253D7, 0x25C22, 0x264A8, 0x26D5C, 0x2764C, 0x27F6F, 0x288D4,
0x29275, 0x29C56, 0x2A67A, 0x2B0DE, 0x2BB92, 0x2C68D, 0x2D1DE, 0x2DD7D, 0x2E972, 0x2F5C2, 0x3026E, 0x30F83, 0x31CFA, 0x32AE1, 0x3393D,
0x34810, 0x3575F, 0x36738, 0x3779A, 0x3888C, 0x39A23, 0x3AC56, 0x3BF3B, 0x3D2DE, 0x3E73E, 0x3FC71, 0x41282, 0x42978, 0x4416F, 0x45A6B,
0x47487, 0x48FD2, 0x4AC63, 0x4CA51, 0x4E9BA, 0x50AB9, 0x52D6A, 0x551F2, 0x57879, 0x5A12D, 0x5CC3C, 0x5F9E1, 0x62A51, 0x65DD9, 0x694C2,
0x6CF69, 0x70E2E, 0x7518F, 0x79A0F, 0x7E844, 0x83CED, 0x898E2, 0x8FD14, 0x96AB3, 0x9E326, 0xA6824, 0xAFBB9, 0xBA075, 0xC598C, 0xD2AFB,
0xE19F5, 0xF2D28, 0x106D91, 0x11E758, 0x13AB64, 0x15D20C, 0x187F97, 0x1BEC7E, 0x20760A, 0x26C1B0, 0x301412, 0x3F4CED, 0x5C9ED2, 0xAC8566, };
//==============================================================================
long atan_fx(long aVal)
{
  unsigned int sign = 0, i;  // 1 = negative
  if(aVal < 0)
  {
    aVal = q_mul(aVal, toFixed(-1000));
    sign = 1;
  }

   for(i = 0; i < (sizeof(SIN_TABLE) / 4); i++)
   {
     if(aVal <= TAN_TABLE[i])
     {
       long     res = q_div(toFixed(i * 100), toFixed(2000));
       if(sign) res = q_mul(res,        toFixed(-1000));
       return res;
     }
   }
  return 1000;
}
//==============================================================================
long sin_fx(long x, long y)
{
  return  q_div(y, sqrt_fx(q_add(q_mul(x, x), q_mul(y, y))));
}
//==============================================================================
long cos_fx(long x, long y)
{
  return  q_div(x, sqrt_fx(q_add(q_mul(x, x), q_mul(y, y))));
}
//===========================================================================
